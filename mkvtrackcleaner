#!/bin/sh

###
# Wanted languages to keep
##
WANTED_LANGS=(
    "und"
    "eng"
    "swe"
    "jap"
    "jpn"
)


###
# Paths to used programs
##
MKVMERGE=$(which mkvmerge)
PRINTF=$(which printf)
FIND=$(which find)
GREP=$(which grep)
SED=$(which sed)
WC=$(which wc)


###
# Regexes
##
GREP_MATCH_AUDIO='Track ID (\d*): audio .* \[.*language:([^\s]+).*'
GREP_MATCH_SUBS='Track ID (\d*): subtitles .* \[.*language:([^\s]+).*'

SED_EXTRACT_INFO='s/Track ID ([0-9]*): .*language:(...).*/\1\t\2/'

###
# Wrapper to do cleaning of files
##
cleanFile() {
    if ! test -f "$1"; then
        echo 'FILE is not a regular file' >&2
        exit 2
    fi

    FILE=$1


    # Run mkvmerge identify to check contents of file
    OUTPUT=$($MKVMERGE --identify-verbose "$FILE")


    # If failure, skip out and continue loop
    if test $? -ne 0; then
        echo 'Failed to identify '$FILE >&2
        continue
    fi


    # Variables to collect all audio and subtitle tracks in the file
    AUDIO=()
    SUBTITLE=()


    # Variables to collect all audio and subtitle tracks we want to keep
    WANTED_AUDIO=()
    WANTED_SUBTITLE=()


    # Loop through lines in output
    IFS=$'\n'
    for LINE in $OUTPUT; do
        # Match if current track is a audio track
        if test $(echo $LINE | $GREP -P $GREP_MATCH_AUDIO | $WC -l) -ne 0; then
            ROW=$(echo $LINE | $SED -E $SED_EXTRACT_INFO)

            AUDIO+=($ROW)

            # Filter through languages we want
            for LANG in "${WANTED_LANGS[@]}"; do
                if test $(echo $ROW | grep $LANG | wc -l) -ne 0; then
                    WANTED_AUDIO+=($ROW)
                fi
            done
        fi

        # Match if current track is a subtitle track
        if test $(echo $LINE | $GREP -P $GREP_MATCH_SUBS | $WC -l) -ne 0; then
            ROW=$(echo $LINE | $SED -E $SED_EXTRACT_INFO)

            SUBTITLE+=($ROW)

            # Filter through languages we want
            for LANG in "${WANTED_LANGS[@]}"; do
                if test $(echo $ROW | grep $LANG | wc -l) -ne 0; then
                    WANTED_SUBTITLE+=($ROW)
                fi
            done
        fi
    done
    unset IFS

    # If there's no wanted audio tracks, just save all the tracks
    if test ${#WANTED_AUDIO[@]} -eq 0; then
        WANTED_AUDIO=$AUDIO
    fi


    echo "=================================="
    echo "File: "$FILE
    echo "Audio tracks:"
    $PRINTF "%s\n" "${AUDIO[@]}"
    echo "Subtitle tracks:"
    $PRINTF "%s\n" "${SUBTITLE[@]}"

    echo

    echo "Audio tracks: (filtered)"
    $PRINTF "%s\n" "${WANTED_AUDIO[@]}"
    echo "Subtitle tracks: (filtered)"
    $PRINTF "%s\n" "${WANTED_SUBTITLE[@]}"
}


###
# Wrapper to loop through all mkv files recurively in a directory to
# run cleanFile on each mkv-file
##
cleanDirectory() {
    $FIND $1 -type f -iname '*.mkv' -print0 | while read -d $'\0' FILE; do
        cleanFile "$FILE"
    done
}


###
# If parameter is a file, run this file
##
if test -f "$1"; then
    cleanFile "$1"
fi


###
# If parameter is a directory, run for directories
##
if test -d "$1"; then
    cleanDirectory "$1"
fi
