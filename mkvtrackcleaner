#!/bin/sh

###
# Wanted languages to keep
##
WANTED_LANGS=(
    "und"
    "eng"
    "swe"
    "jap"
    "jpn"
)


###
# Paths to used programs
##
MKVMERGE=$(which mkvmerge)
FIND=$(which find)
GREP=$(which grep)
SED=$(which sed)


###
# Regexes
##
GREP_MATCH_AUDIO='Track ID (\d*): audio .* \[.*language:([^\s]+).*'
GREP_MATCH_SUBS='Track ID (\d*): subtitles .* \[.*language:([^\s]+).*'

SED_EXTRACT_INFO='s/Track ID ([0-9]*): .*language:(...).*/\1\t\2/'

###
# Wrapper to do cleaning of files
##
cleanFile() {
    if ! test -f "$1"; then
        echo 'FILE is not a regular file' >&2
        exit 2
    fi

    FILE=$1

    # Run mkvmerge identify to check contents of file
    OUTPUT=$($MKVMERGE --identify-verbose "$FILE")

    # If failure, skip out and continue loop
    if test $? -ne 0; then
        echo 'Failed to identify '$FILE >&2
        continue
    fi

    # Find audio and subtitle tracks
    AUDIO=()
    SUBTITLE=()

    IFS=$'\n'
    for LINE in $OUTPUT; do
        # Match if current track is a audio track
        if test $(echo $LINE | $GREP -P $GREP_MATCH_AUDIO | wc -l) -ne 0; then
            AUDIO+=($(echo $LINE | $SED -E $SED_EXTRACT_INFO))
        fi

        # Match if current track is a subtitle track
        if test $(echo $LINE | $GREP -P $GREP_MATCH_SUBS | wc -l) -ne 0; then
            SUBTITLE+=($(echo $LINE | $SED -E $SED_EXTRACT_INFO))
        fi
    done
    unset IFS

    echo "=================================="
    echo "File: "$FILE
    echo "Audio tracks:"
    printf "%s\n" "${AUDIO[@]}"
    echo "Subtitle tracks:"
    printf "%s\n" "${SUBTITLE[@]}"
}


###
# Wrapper to loop through all mkv files recurively in a directory to
# run cleanFile on each mkv-file
##
cleanDirectory() {
    $FIND $1 -type f -iname '*.mkv' -print0 | while read -d $'\0' FILE; do
        cleanFile "$FILE"
    done
}


###
# If parameter is a file, run this file
##
if test -f "$1"; then
    cleanFile "$1"
fi


###
# If parameter is a directory, run for directories
##
if test -d "$1"; then
    cleanDirectory "$1"
fi
