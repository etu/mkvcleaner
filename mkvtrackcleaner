#!/usr/bin/env bash

###
# Wanted languages to keep
##
WANTED_LANGS=(
    "und"
    "eng"
    "swe"
    "jap"
    "jpn"
)


###
# Wrapper to do cleaning of files
##
cleanFile() {
    if ! test -f "$1"; then
        echo 'FILE is not a regular file' >&2
        exit 2
    fi

    FILE=$1


    # Use ffprobe to get the tracks of the file and make the json
    # compact with jq.
    OUTPUT=$(ffprobe -hide_banner -show_entries stream -print_format json -v panic -i "$FILE" | jq -c)


    # If failure, skip out and continue loop
    if test $? -ne 0; then
        echo 'Failed to probe '$FILE >&2
        return
    fi


    # Variables to collect all tracks in the file.
    AUDIO=()
    SUBTITLE=()
    VIDEO=()


    # Variables to collect all tracks in the file to keep.
    WANTED_AUDIO=()
    WANTED_SUBTITLE=()
    WANTED_VIDEO=()


    # Loop through all tracks, temporary base64 encode them to not
    # have spaces and stuff to mess up the loop.
    for stream in $(echo $OUTPUT | jq -r -c '.streams[] | @base64'); do
        # Identify which type of stream it is, audio or
        # subtitle. Ignore other types of streams.
        case $(echo $stream | base64 -d | jq -r -c '.codec_type') in
            audio)
                AUDIO+=($stream)

                for LANG in "${WANTED_LANGS[@]}"; do
                    if test $(echo $stream | base64 -d | jq -r -c 'select(.tags.language == "'$LANG'")' | wc -l) -ne 0; then
                        WANTED_AUDIO+=($stream)
                    fi
                done
                ;;

            subtitle)
                SUBTITLE+=($stream)

                for LANG in "${WANTED_LANGS[@]}"; do
                    if test $(echo $stream | base64 -d | jq -r -c 'select(.tags.language == "'$LANG'")' | wc -l) -ne 0; then
                        WANTED_SUBTITLE+=($stream)
                    fi
                done
                ;;

            video)
                VIDEO+=($stream)

                for LANG in "${WANTED_LANGS[@]}"; do
                    if test $(echo $stream | base64 -d | jq -r -c 'select(.tags.language == "'$LANG'")' | wc -l) -ne 0; then
                        WANTED_VIDEO+=($stream)
                    fi
                done
                ;;
        esac
    done


    # If there's no wanted video tracks, just save all the tracks.
    if test ${#WANTED_VIDEO[@]} -eq 0; then
        WANTED_VIDEO=$VIDEO
    fi


    # If there's no wanted audio tracks, just save all the tracks.
    if test ${#WANTED_AUDIO[@]} -eq 0; then
        WANTED_AUDIO=$AUDIO
    fi


    # Check for change and bail out if we don't need to mux the file.
    if test    ${#WANTED_AUDIO[@]}    -eq ${#AUDIO[@]}    \
            -a ${#WANTED_SUBTITLE[@]} -eq ${#SUBTITLE[@]} \
            -a ${#WANTED_VIDEO[@]}    -eq ${#VIDEO[@]}; then
        echo "No change after filtering detected, skipping: "$FILE >&2
        return
    fi


    # Start building command to run.
    CMD=$(echo 'ffmpeg -i '$FILE)


    # Specify video tracks to keep.
    if ! test ${#WANTED_VIDEO[@]} -eq 0; then
        for TRACK in "${WANTED_VIDEO[@]}"; do
            CMD+=" -map 0:v:"$(echo $TRACK | base64 -d | jq -r -c '.index')
        done
    fi


    # Specify audiotracks to keep.
    if ! test ${#WANTED_AUDIO[@]} -eq 0; then
        for TRACK in "${WANTED_AUDIO[@]}"; do
            CMD+=" -map 0:a:"$(echo $TRACK | base64 -d | jq -r -c '.index')
            # Set -disposition:s:0 default to zero somehow to make it not default
        done
    fi


    # Specify subtitle tracks to keep.
    if ! test ${#WANTED_SUBTITLE[@]} -eq 0; then
        for TRACK in "${WANTED_SUBTITLE[@]}"; do
            CMD+=" -map 0:s:"$(echo $TRACK | base64 -d | jq -r -c '.index')
            # Set -disposition:s:0 default to zero somehow to make it not default
        done
    fi

    # Add output filename
    CMD+=" $FILE.tmp"

    echo -n "Transcoding $FILE ... "
    echo $CMD
    OUTPUT=$($CMD)

    # Print message success or failure message
    if test $? -ne 0; then
        echo "Failed :("

        # TODO: echo $OUTPUT

        # Remove temp file after failure
        # TODO: rm $FILE'.tmp'
    else
        echo "Success :)"

        # Replace original file after success
        # TODO: mv $FILE'.tmp' $FILE
    fi
}


###
# Wrapper to loop through all mkv files recurively in a directory to
# run cleanFile on each mkv-file
##
cleanDirectory() {
    find $1 -type f -iname '*.mkv' -print0 | while read -d $'\0' FILE; do
        cleanFile "$FILE"
    done
}


###
# If parameter is a file, run this file
##
if test -f "$1"; then
    cleanFile "$1"
fi


###
# If parameter is a directory, run for directories
##
if test -d "$1"; then
    cleanDirectory "$1"
fi
